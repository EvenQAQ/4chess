#include <iostream>#include <unistd.h>#include <ctime>#include <cmath>#include "Point.h"#include "Judge.h"#include "Strategy.h"using namespace std;class Status{private:	int n, m, noX, noY, lastX, lastY, player;    int **board;    int *top;    int limits;	Status **children;    Status *parent;    int expandTotal;    int *expandNum;    int visitedNum;    double profit;public:    Status(int **_board, int *_top, int _n, int _m, int _noX, int _noY, int _lastX, int _lastY, int _player, Status *_father):    board(_board), top(_top), n(_n), m(_m), noX(_noX), noY(_noY), lastX(_lastX), lastY(_lastY), player(_player), parent(_father), limits(2), profit(0), expandTotal(0)    {    	children = new Status*[_n];    	for (int i = 0; i < _n; i++)    		{    			children[i] = NULL;    			if (_top[i] != 0)    				{    					expandNum[expandTotal] = i;    					expandTotal++;    				}    		}    	if (_lastX-1 == noX && _lastY == noY)	top[_lastY]--;    }    int getX();    int getY();    void debug();    bool canExpand();    Status* expand();    bool isEnd();    Status* bestChild();    void backup(double delta);    void setLimits(int time);    void put(int **board, int *top, int player, int x, int y);	Status* uctSearch();	Status* treePolicy(Status* temp);	double defaultPolicy();    ~Status()    {    	for (int i = 0; i < m; i++)    		delete board[i];    	delete []board;    	delete []top;    	delete []parent;    	for (int i = 0; i < n; i++)    		delete []children;    	//delete    }};int Status::getX(){	return lastX;}int Status::getY(){	return lastY;}void Status::debug(){	cout << n << "-" << m << "-" << noX << "-" << noY << "-" << lastX << "-" << lastY << endl;}bool Status::canExpand(){	if (expandTotal > 0)		return true;	else return false;}Status* Status::expand(){	int index, X, Y;	while(1)	{		index = rand() % expandTotal;		Y = expandNum[index];		X = top[Y];		if (X == noX && Y == noY)			continue;		else			break;	}	int **tempboard = board;	int *temptop = top;	tempboard[X][Y] = 3-player;	temptop[Y]--;	if (X == noX && Y == noY)		temptop[Y]--;	children[Y] = new Status(tempboard, temptop, n, m, noX, noY, X, Y, 3-player, this);	return children[Y]; }bool Status::isEnd(){	if (machineWin(lastX, lastY, m, n, board) || userWin(lastX, lastY, m, n, board) || isTie(n, top))		return true;	else return false;}Status* Status::bestChild(){	Status *bestChild;	double maxProfit;	for (int i = 0; i < n; i ++)	{		if (children[i] == NULL) continue;		double modifiedProfit = (player == 1 ? -1 : 1) * children[i] -> profit; //修正收益值			int childVisitedNum = children[i] -> visitedNum; //子节点访问数 			double tempProfit = modifiedProfit / childVisitedNum + 				sqrtl(2 * logl(visitedNum) / childVisitedNum) * 1; //计算综合收益率 			if (tempProfit > maxProfit || (tempProfit == maxProfit && rand() % 2 == 0)) { //选择综合收益率最大的子节点 				maxProfit = tempProfit;				bestChild = children[i];			}	}	return bestChild;}void Status::backup(double delta){	Status *temp = this;		while (temp) 		{			temp -> visitedNum ++; //访问次数+1 			temp -> profit += delta; //收益增加delta 			temp = temp -> parent;		}}void Status::setLimits(int time){	this->limits = time;}Status* Status::uctSearch()	{		int start = clock();		int t = 0;		Status *root = new Status(board, top, n, m, noX, noY, lastX, lastY, player, NULL);		while (t < limits)		{			Status *node = treePolicy(root);			double delta = node->defaultPolicy();			node->backup(delta);			t = clock() - start;		}		return root->bestChild();	}Status* Status::treePolicy(Status *temp){	while (temp -> isEnd() != 1) { //节点不是终止节点 			if (temp -> canExpand()) //且拥有未被访问的子状态 				return temp->expand(); //扩展该节点 			else				temp = temp->bestChild(); //选择最优子节点 		}		return temp;}void Status::put(int **board, int *top, int player, int x, int y){	y = rand() % n; //随机选择一列 	while (top[y] == 0) //若此列已下满 		y = rand() % n; //再随机选择一列 	x = top[y]; //确定落子高度 	board[x][y] = player; //落子 	if (x - 1 == noX && y == noY) //若落子位置正上方紧邻不可落子点 		top[y]--;	cout << "put--" << x << "--" << y << endl;}double Status::defaultPolicy(){	int **tempboard = this -> board, *temptop = this -> top;	int tempplayer = this -> player;	int x = this -> lastX, y = this -> lastY;	double tempprofit = 2; //计算收益 	while (tempprofit == 2) 	{ //若当前状态未达终止状态 		put(tempboard, temptop, tempplayer, x, y); //随机落子 		if (tempplayer == 1 && userWin(x, y, m, n, tempboard))			tempprofit =  -1;		if (player == 2 && machineWin(x, y, m, n, tempboard))			tempprofit =  1;		if (isTie(n, top))			tempprofit =  0;		else tempprofit = 2; //计算收益 		tempplayer = 3 - tempplayer; //棋权变换 	}	for (int i = 0; i < m; i ++)		delete [] tempboard[i];	delete [] tempboard;	delete [] temptop;	return tempprofit;}/*	策略函数接口,该函数被对抗平台调用,每次传入当前状态,要求输出你的落子点,该落子点必须是一个符合游戏规则的落子点,不然对抗平台会直接认为你的程序有误		input:		为了防止对对抗平台维护的数据造成更改，所有传入的参数均为const属性		M, N : 棋盘大小 M - 行数 N - 列数 均从0开始计， 左上角为坐标原点，行用x标记，列用y标记		top : 当前棋盘每一列列顶的实际位置. e.g. 第i列为空,则_top[i] == M, 第i列已满,则_top[i] == 0		_board : 棋盘的一维数组表示, 为了方便使用，在该函数刚开始处，我们已经将其转化为了二维数组board				你只需直接使用board即可，左上角为坐标原点，数组从[0][0]开始计(不是[1][1])				board[x][y]表示第x行、第y列的点(从0开始计)				board[x][y] == 0/1/2 分别对应(x,y)处 无落子/有用户的子/有程序的子,不可落子点处的值也为0		lastX, lastY : 对方上一次落子的位置, 你可能不需要该参数，也可能需要的不仅仅是对方一步的				落子位置，这时你可以在自己的程序中记录对方连续多步的落子位置，这完全取决于你自己的策略		noX, noY : 棋盘上的不可落子点(注:涫嫡饫锔?龅膖op已经替你处理了不可落子点，也就是说如果某一步				所落的子的上面恰是不可落子点，那么UI工程中的代码就已经将该列的top值又进行了一次减一操作，				所以在你的代码中也可以根本不使用noX和noY这两个参数，完全认为top数组就是当前每列的顶部即可,				当然如果你想使用lastX,lastY参数，有可能就要同时考虑noX和noY了)		以上参数实际上包含了当前状态(M N _top _board)以及历史信息(lastX lastY),你要做的就是在这些信息下给出尽可能明智的落子点	output:		你的落子点Point*/extern "C" Point* getPoint(const int M, const int N, const int* top, const int* _board, 	const int lastX, const int lastY, const int noX, const int noY){	/*		不要更改这段代码	*/	int x = -1, y = -1;//最终将你的落子点存到x,y中	int** board = new int*[M];	for(int i = 0; i < M; i++){		board[i] = new int[N];		for(int j = 0; j < N; j++){			board[i][j] = _board[i * N + j];		}	}		/*		根据你自己的策略来返回落子点,也就是根据你的策略完成对x,y的赋值		该部分对参数使用没有限制，为了方便实现，你可以定义自己新的类、.h文件、.cpp文件	*/	//Add your own code below    /*     //a naive example	for (int i = N-1; i >= 0; i--) {		if (top[i] > 0) {			x = top[i] - 1;			y = i;			break;		}	}    */    int temptop[13] = {};    for (int i = 0; i < N; i++)    	temptop[i] = top[i];	Status *uct = new Status(board, temptop, N, M, noX, noY, lastX, lastY, 2, NULL);	uct->setLimits(1);	uct = uct->uctSearch();	uct->debug(); 	x = uct->getX();	y = uct->getY();	/*		不要更改这段代码	*/	clearArray(M, N, board);	return new Point(x, y);}/*	getPoint函数返回的Point指针是在本dll模块中声明的，为避免产生堆错误，应在外部调用本dll中的	函数来释放空间，而不应该在外部直接delete*/extern "C" void clearPoint(Point* p){	delete p;	return;}/*	清除top和board数组*/void clearArray(int M, int N, int** board){	for(int i = 0; i < M; i++){		delete[] board[i];	}	delete[] board;}/*	添加你自己的辅助函数，你可以声明自己的类、函数，添加新的.h .cpp文件来辅助实现你的想法*/